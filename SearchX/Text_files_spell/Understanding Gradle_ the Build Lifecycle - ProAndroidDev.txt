Understanding Gradle: the Build Lifecycle - ProAndroidDev Sign in Open in app Get started Submit Archive About Events droidcon Understanding Gradle: the Build Lifecycle Rygel Louv Follow May 19, 2018 · 5 min read It is quite easy to find articles about “how to create gradle custom tasks”, “how to decrease build time”, “how to structure gradle build files” etc. But not very common to find articles about how Gradle really works under the hood. Today, let’s focus on a small part of the “dark side” of Gradle: the build lifecycle. Before we go through the explanation of the Gradle build lifecycle, lets agree on some capital definitions in the Gradle universe. Project This is one of the most important concept for Gradle. In fact, a project is a representation of what needs to be built and leads to an artifact at the end of the build. For example, on Android the :app module is a Gradle project. If you have another module in your Android project (don’t get confused here), that module also is a project for Gradle. Projects are registered in the settings.gradle file Most of the time, a projet has a build.gradle file Task A task, as the name suggests, is a representation of actions (default or custom) that need to be executed during the build process. For example, the compilation of Java code is started by a task. Tasks are defined in the project build script and can have dependencies with each other. Now that we know these capital terms let’s dive into the main subject Build Phases Every Gradle build goes through 3 different lifecycle phases following the same order every time. The initialization phase In this phase, Gradle tries to identify all the projects involved in the build process. It is very important for Gradle to know whether it’s a Single-project build or a Multi-project build. In a Multi-project build there are several projects to evaluate. Hence, several build scripts. Gradle looks at the settings.gradle file in order to identify the different projects. At the end of the initialization phase, Gradle creates an instance of org.gradle.api.Project corresponding to each of these projects. The configuration phase During this phase, Gradle executes the build script of each project identified in the previous phase. Actually, it is very important to know that just because we say “Gradle executes the build scripts” does not mean that the Tasks in those build scripts are executed too. Instead, after evaluating those scripts as simple Groovy scripts and identify the tasks in it, Gradle builds a Directed Acyclic Graph (DAG) of task objects. A DAG is a mathematical algorithm for representing a graph that contains no cycles. The “directed” term means each dependency arrow goes in one direction. “Acyclic” means that there are no loops in the graph. Directed acyclic graph for the Java plug-in tasks from the book Gradle Recipes for Android. Also one thing to mention in the Configuration phase is that Gradle introduced a feature called configuration on demand that gives it the ability to configure only the relevant and necessary projects during the build process. This is very useful in large Multi-project builds because it could considerably decrease build time. The execution phase This is the last phase. During this phase, Gradle identifies the tasks that need to be executed based on the DAG of task objects created in the previous phase, and executes them according to their dependency order. All the build work and activities are actually done in this phase. For example: compiling source code and generating .class files, copying files, cleaning build directory, uploading archives, archiving files etc. This is cool but what does it look like in real life ? Well, in “real life” the phases could easily be identified in your gradle files. For example if you put a code in the settings.gradle file, it is evaluated in the initialization phase. The code in your build script files that are not related to actions of your tasks are evaluated in the configuration phase. And finally the code in the actual actions of your tasks like the doLast closures of your tasks are evaluated in the execution phase. Let’s take a look: settings.gradle build.gradle And the result of the build after entering the command gradle test testBoth Output of gradle test testBoth Let’s wrap it up This single image can give you an idea of what we’ve been talking about throughout this article. We represent here in a very simple and stupid way the build process that takes us to the generation of a jar but it could be anything else like aar, apk, war etc. The 3 build lifecycle phases with their output Thank you for reading, i hope i helped you learn something new in one way or another. Perhaps i forgot something, perhaps i was wrong somewhere, if so, just leave a comment so we can discuss about it. References Note that here we try to give a simple and high-level explanation of all these stuff but you can dive deep in it by helping yourself with the references bellow. Gradle Beyond the Basics If you're familiar with Gradle's basics elements-possibly through the author's previous O'Reilly book, Building and… www.safaribooksonline.com Gradle Recipes for Android Android adopted Gradle as the preferred build automation system a few years ago, but many Android developers are still… shop.oreilly.com Introducing Gradle This concise book is a quick-start primer on the Gradle build automation tool. It provides a general introduction to… www.safaribooksonline.com Build Lifecycle We said earlier that the core of Gradle is a language for dependency based programming. In Gradle terms this means that… docs.gradle.org ProAndroidDev The latest posts from Android Professionals and Google… Follow 609 Gradle Java Kotlin Android Compilers 609 claps Written by Rygel Louv Follow Android developer. Passionate about Software Engineering, AI, and Machine Learning. Follow ProAndroidDev Follow The latest posts from Android Professionals and Google Developer Experts. Follow See responses (4) More From Medium More from ProAndroidDev More from ProAndroidDev Implementing The Motion System with material components for Android Somesh Kumar in ProAndroidDev Mar 16 · 5 min read 428 More from ProAndroidDev More from ProAndroidDev Evolution of location access on Android Denys Soroka in ProAndroidDev Mar 20 · 8 min read 321 More from ProAndroidDev More from ProAndroidDev Authorization and retrying of web requests for OkHttp and Retrofit Andrew Lord in ProAndroidDev Mar 16 · 5 min read 247 Discover MediumWelcome to a place where words matter. On Medium, smart voices and original ideas take center stage - with no ads in sight. Watch Make Medium yoursFollow all the topics you care about, and we’ll deliver the best stories for you to your homepage and inbox. Explore Become a memberGet unlimited access to the best stories on Medium — and support writers while you’re at it. Just $5/month. Upgrade AboutHelpLegal